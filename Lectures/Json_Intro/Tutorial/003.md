# Stage 3 — Accessing and Traversing JSON

## Learning goals

- Access values using keys or indices.
- Check existence safely.
- Iterate through arrays and objects.
- Inspect types when exploring unknown data.

---

## 1️⃣ Direct key access

JSON objects act like maps, and arrays act like vectors.

```cpp
#include <iostream>
#include "json.hpp"
using json = nlohmann::json;

int main() {
    json j = {
        {"name", "Artemis"},
        {"age", 23},
        {"skills", {"C++", "Python", "IoT"}}
    };

    std::cout << j["name"] << std::endl;      // Artemis
    std::cout << j["skills"][0] << std::endl; // C++
}
```

**Caution:**  
Accessing a missing key (e.g., `j["unknown"]`) _creates_ it with `null`.  
Use `.at()` or `.contains()` when you want safety.

---

## 2️⃣ Safe access and bounds checking

```cpp
if (j.contains("age"))
    std::cout << "Age: " << j["age"] << std::endl;

// throws exception if missing
try {
    std::cout << j.at("height") << std::endl;
}
catch (std::exception& e) {
    std::cout << "Missing key: " << e.what() << std::endl;
}
```

---

## 3️⃣ Type inspection

```cpp
if (j["name"].is_string())
    std::cout << "Name is a string\n";

if (j["age"].is_number_integer())
    std::cout << "Age is an integer\n";

if (j["skills"].is_array())
    std::cout << "Skills is an array of size " << j["skills"].size() << "\n";
```

Useful functions:

- `is_string()`
- `is_number_integer()`
- `is_number_float()`
- `is_boolean()`
- `is_array()`
- `is_object()`
- `is_null()`
- `type_name()` → returns `"string"`, `"array"`, etc.

---

## 4️⃣ Iterating through arrays

```cpp
for (auto& s : j["skills"]) {
    std::cout << "- " << s << std::endl;
}
```

Output:

```
- C++
- Python
- IoT
```

---

## 5️⃣ Iterating through objects

```cpp
for (auto& [key, value] : j.items()) {
    std::cout << key << " : " << value << std::endl;
}
```

Output:

```
name : "Artemis"
age : 23
skills : ["C++","Python","IoT"]
```

The structured binding `[key, value]` makes this super clean and readable.

---

## 6️⃣ Recursion and nested traversal (optional advanced)

Sometimes you want to walk through _everything_, even nested objects.  
This is how you could do it recursively:

```cpp
void print_json(const json& j, int depth = 0) {
    std::string indent(depth * 2, ' ');
    if (j.is_object()) {
        for (auto& [k, v] : j.items()) {
            std::cout << indent << k << ":\n";
            print_json(v, depth + 1);
        }
    } else if (j.is_array()) {
        for (auto& v : j)
            print_json(v, depth + 1);
    } else {
        std::cout << indent << j << "\n";
    }
}
```

Then call:

```cpp
print_json(j);
```

Students get a feel for **recursive structures** — perfect prep for tree concepts later.

---

## 7️⃣ Quick reference table

| Operation       | Example                       | Notes                  |
| --------------- | ----------------------------- | ---------------------- |
| Direct access   | `j["key"]`                    | creates key if missing |
| Safe access     | `j.at("key")`                 | throws if missing      |
| Check existence | `j.contains("key")`           | true/false             |
| Array element   | `j["arr"][i]`                 | zero-based             |
| Iterate array   | `for(auto &v : j["arr"])`     | easy loops             |
| Iterate object  | `for(auto &[k,v]: j.items())` | map-style              |
| Inspect type    | `j["x"].type_name()`          | returns string name    |

---

## 8️⃣ Micro-exercises

A) **Access practice**  
Given:

```cpp
json hero = {
  {"name", "Luna"},
  {"level", 7},
  {"stats", {{"hp", 80}, {"mp", 50}}},
  {"skills", {"Magic", "Stealth"}}
};
```

Print:

- The hero’s name
- The first skill
- The hero’s HP

Then add a new skill `"Alchemy"` to the array.

---

B) **Iteration practice**  
Iterate through `hero` and print all key names and types.

Example output:

```
name -> string
level -> number
stats -> object
skills -> array
```

---

C) **Challenge:**  
Write a small loop that prints every primitive value in the JSON, regardless of depth.  
(Hint: recursion or a helper function using `.is_object()` and `.is_array()`.)

---

|                   |                   |
| :---------------: | :---------------: |
| [⏮️ Prev](002.md) | [Next ⏭️](004.md) |
