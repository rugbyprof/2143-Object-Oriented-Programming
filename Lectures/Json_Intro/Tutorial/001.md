# Stage 1 ‚Äî JSON Foundations (Language-Agnostic)

## Learning goals

- Recognize JSON‚Äôs six data types.
- Read and reason about nested JSON.
- Know what JSON is good/bad at (so you don‚Äôt misuse it).

## 1) What JSON is (and isn‚Äôt)

- **Is:** a **text** format for structured data; language-agnostic; ubiquitous.
- **Isn‚Äôt:** code (no functions/loops), schema-enforced (by default), or compact/binary.

## 2) The six building blocks

Primitives

```json
"hello"         // string
42              // number (int/float both look like "number")
true            // boolean
null            // null
```

Compounds

```json
[1, 2, 3]       // array (ordered list)
{ "k": "v" }    // object (key‚Üívalue map; keys are strings)
```

## 3) Composition & nesting (the whole game)

```json
{
  "name": "Artemis",
  "age": 23,
  "is_student": true,
  "skills": ["C++", "Python", "IoT"],
  "address": { "city": "Wichita Falls", "state": "TX" },
  "projects": [
    { "title": "Smart Sensor", "completed": false },
    { "title": "3D Printer Monitor", "completed": true }
  ]
}
```

Reading tips:

- Objects = unordered maps.
- Arrays = ordered sequences.
- Values can be _any_ of the six types, at any depth.

## 4) Strengths vs. Weaknesses (why/when to use)

**Pros**

- Human-readable, easy to debug.
- Cross-language and widely supported (APIs, configs, logs).
- Flexible: can represent most data you‚Äôll use in undergrad projects.

**Cons**

- **Bloated** vs binary (larger files, slower parse).
- **No comments** in the spec (workarounds exist, but teach ‚Äúno comments‚Äù).
- Numbers are generic ‚Äúnumber‚Äù ‚Üí you don‚Äôt control `int` vs `double`.

## 5) Gotchas students hit

- Trailing commas aren‚Äôt allowed.
- Keys **must** be in double quotes.
- Strings **must** be double-quoted (no single quotes).
- Duplicate keys: last one wins (but don‚Äôt rely on it).
- JSON != JavaScript: looks similar, but JSON has stricter rules.

Bad vs good:

```json
// ‚ùå bad
{ name: 'Artemis', }   // unquoted key, single quotes, trailing comma

// ‚úÖ good
{ "name": "Artemis" }
```

## 6) Json Types and C++ partners

| Component   | Description                                                                         | Example                          | C++ Equivelent            |
| ----------- | ----------------------------------------------------------------------------------- | -------------------------------- | ------------------------- |
| **Object**  | An unordered collection of key‚Äìvalue pairs (like a C++ `std::map` or Python `dict`) | `{ "name": "Terry", "age": 42 }` | `std::map<std::string,T>` |
| **Array**   | An ordered list of values (like a `std::vector`)                                    | `[1, 2, 3, 4]`                   | `std::vector<T>`          |
| **String**  | Text enclosed in double quotes                                                      | `"hello world"`                  | `std::string`             |
| **Number**  | Integers or floats                                                                  | `42`, `3.14`                     | `int`/`double`            |
| **Boolean** | Logical values                                                                      | `true`, `false`                  | `bool`                    |
| **Null**    | Represents the absence of a value                                                   | `null`                           | `std::optional`           |

> <sup>üß† **Note:** </sup><br><sup>std::optional is a C++ utility that acts as a container for a value that may or may not be present. It can be used to represent a "null" or empty value, clearly communicating the possibility of a missing value without using pointers or special sentinel values. To check for a value, you can use the has_value() method or a contextual conversion to bool, which returns true if a value is present and false otherwise.</sup>

These six pieces form _everything_ you‚Äôll ever see in JSON ‚Äî no classes, no pointers, no weird syntax.  
That‚Äôs part of its charm: **simplicity + universality**.

## 7) Tiny comprehension checks (1‚Äì2 minutes)

1. Is this valid JSON? Why/why not?

```json
{ "items": [1, 2, 3], "ok": true }
```

<details>
<summary>üí° Answer</summary>
‚Üí No (trailing comma in array).
</details>

2. What type is `"age"` here?

```json
{ "age": "23" }
```

<details>
<summary>üí° Answer</summary>
‚Üí String (not a number).
</details>

3. What prints if you read key `"city"` from this?

```json
{ "address": { "city": "WF" } }
```

<details>
<summary>üí° Answer</summary>
‚Üí You must traverse  (reach into the object using a second key: city)`["address"]["city"]`.
</details>

## 8) Micro-exercises (5‚Äì10 minutes total)

A) **Validate** (you fix errors):

```json
{
  name: "Kai",
  "skills": ["C++", "Python",],
  "admin": True
}
```

Target:

```json
{
  "name": "Kai",
  "skills": ["C++", "Python"],
  "admin": true
}
```

B) **Extend** the nested object by adding:

- `"gpa": 3.6`
- `"contact": { "email": "kai@msu.edu", "phone": null }`
- Append `"Data Science"` to `"skills"`.

C) **Modeling task**  
Represent a course roster as JSON with:

- course code, title
- array of students (name, id, major)
- meeting times (array of objects with day & time range)
- Keep it small but nested.

## 9) Optional: ‚ÄúJSON vs. YAML vs. CSV‚Äù one-liner

- **JSON** = structured trees; great for configs/APIs.
- **YAML** = like JSON but looser syntax (and comments); easier for humans, easier to break.
- **CSV** = flat tables; great for rows/columns, _bad_ at nesting.

---

|     |                   |
| :-: | :---------------: |
|  -  | [Next ‚è≠Ô∏è](002.md) |
